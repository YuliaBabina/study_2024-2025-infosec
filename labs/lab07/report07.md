# **Отчет к лабораторной работе №7**
## **Common information**
discipline: Основы информационной безопасности  
group: НПМбд-02-21  
author: Бабина Ю. О.
---
---
## **Цель работы**

Освоить на практике применение режима однократного гаммирования.
## **Выполнение работы**

Напишем код на языке программирования Python. 
Импортируем все необходимые библиотеки:

![Импорт библиотек](images/s1.png)

Напишем функцию для генерации случайного ключа заданной длины:

![Генерация случайного ключа](images/s2.png)

Далее реализуем функцию для шифрования и дешифрования текста по заданному ключу (функция будет одна для двух процессов, так как операция исключающего или отменяет сама себя):

![Функция шифрования / дешифрования](images/s3.png)

Теперь реализуем функцию, которая подбирает ключ, с помощью которого шифротекст может быть преобразован в некоторый фрагмент текста, представляющий собой один из возможных вариантов прочтения открытого текста:

![Функция для поиска ключей](images/s4.png)

Проверим корректность работы написанных нами функций:

![Проверка корректности шифрования / дешифрования](images/s5.png)
![Проверка поиска ключей](images/s6.png)

В итоге имеем данную программу:

```Python
import random
import string

def get_random_key(n):
    symbols = string.ascii_letters + string.digits
    return ''.join([random.choice(symbols) for i in range(n)])

def enc_dec(text, key):
    if len(text) != len(key):
        raise ValueError('Длины текста и ключа должны совпадать')
    return ''.join([chr(ord(text[i]) ^ ord(key[i % len(key)])) for i in range(len(text))])

def find_keys(text, part):
    all_keys = []
    for i in range(len(text) - len(part) + 1):
        new_key = ""
        for j in range(len(part)):
            new_key += chr(ord(text[i + j]) ^ ord(part[j]))
        all_keys.append(new_key)
    return all_keys

text = 'С Новым Годом, друзья!'
key = get_random_key(len(text))
enc_text = enc_dec(text, key)
print(f'Текст: {text}')
print(f'Ключ: {key}')
print(f'Шифротекст: {enc_text}')
print(f'Расшифрованный текст: {enc_dec(enc_text, key)}')

part='С Новым'
potential_keys = find_keys(text, part)
print(f'Список ключей: {potential_keys}')
```

## **Контрольные вопросы**

1. Однократное гаммирование-это метод шифрования, при котором каждый символ открытого текста гаммируется с соответствующим символом ключа только один раз.

2. Недостатки однократного гаммирования:
* Уязвимость к частотному анализу из-за сохранения частоты символов открытого текста в шифротексте.
* Необходимость использования одноразового ключа, который должен быть длиннее самого открытого текста.
* Нет возможности использовать один ключ для шифрования разных сообщений.

3. Преимущества однократного гаммирования:
* Высокая стойкость при правильном использовании случайного ключа.
* Простота реализации алгоритма.
* Возможность использования случайного ключа.

4. Длина открытого текста должна совпадать с длиной ключа, чтобы каждый символ открытого текста гаммировался с соответствующим символом ключа.

5. В режиме однократного гаммирования используется операция XOR (исключающее ИЛИ), которая объединяет двоичные значения символов открытого текста и ключа для получения шифротекста. Особенность XOR - если один из битов равен 1, то результат будет 1, иначе 0.

6. Для получения шифротекста по открытому тексту и ключу каждый символ открытого текста гаммируется с соответствующим символом ключа с помощью операции XOR.

7. По открытому тексту и шифротексту невозможно восстановить действительный ключ, так как для этого нужна информация о каждом символе ключа.

8. Необходимые и достаточные условия абсолютной стойкости шифра:
* Ключи должны быть случайными и использоваться только один раз.
* Длина ключа должна быть не менее длины самого открытого текста.
* Ключи должны быть храниться и передаваться безопасным способом.

## **Вывод**
В рамках выполнения данной лабораторной работы я освоила на практике применение режима однократного гаммирования.

## **Список литературы** ##
* https://bugtraq.ru/library/books/crypto/chapter7/
* https://www.youtube.com/watch?v=tAjBULW_OjQ